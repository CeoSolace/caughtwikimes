<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VoidChat Room</title>
  <link rel="manifest" href="/manifest.json"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    .g { backdrop-filter: blur(12px); background: rgba(30, 30, 46, 0.6); }
    .msg { position: relative; }
    .reply-btn {
      position: absolute;
      top: 50%;
      left: -32px;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s ease, transform 0.2s ease;
      background: rgba(55, 55, 65, 0.8);
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      color: #8c8c94;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .reply-btn:hover {
      background: rgba(70, 70, 80, 0.9);
      color: #b9b9c2;
    }
    .msg:hover .reply-btn {
      opacity: 1;
    }
    .reply { 
      border-left: 2px solid #8b5cf6; 
      padding-left: 8px; 
      font-size: 0.75rem; 
      opacity: 0.85; 
      margin-bottom: 4px; 
      color: #c7c7d7;
    }
    .sender { 
      font-size: 0.75rem; 
      opacity: 0.7; 
      margin-top: 4px; 
      color: #a0a0b0;
    }
    .message-bubble {
      transition: background 0.2s ease;
    }
    .message-bubble:hover {
      filter: brightness(1.05);
    }
  </style>
</head>
<body class="h-full bg-gradient-to-br from-gray-900 via-purple-900 to-indigo-900 text-white flex flex-col max-w-4xl mx-auto p-4 gap-4">

  <!-- Header -->
  <div class="flex justify-between items-center text-xs">
    <span id="code" class="font-mono bg-black/30 px-3 py-1.5 rounded-lg"></span>
    <span id="online" class="bg-black/30 px-3 py-1.5 rounded-lg"></span>
  </div>

  <!-- Last Message -->
  <div id="lm" class="text-xs opacity-60 h-5 text-center text-gray-300"></div>

  <!-- Messages -->
  <div id="msgs" class="flex-1 overflow-y-auto g rounded-xl p-4 space-y-3 text-sm"></div>

  <!-- Reply Preview -->
  <div id="replyPreview" class="hidden bg-black/20 backdrop-blur-sm p-2.5 rounded-lg text-xs mb-1">
    <div class="flex justify-between items-center">
      <span id="replyText" class="truncate max-w-xs text-gray-200"></span>
      <button onclick="cancelReply()" class="text-red-400 hover:text-red-300 text-lg leading-none">×</button>
    </div>
  </div>

  <!-- Input -->
  <div class="flex gap-2">
    <input id="inp" placeholder="Message..." class="flex-1 p-3 rounded-xl bg-black/30 border border-white/10 focus:outline-none focus:ring-2 focus:ring-purple-500/50 text-sm placeholder:text-gray-400"/>
    <button onclick="send()" class="bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 px-5 py-3 rounded-xl text-sm font-bold transition-all shadow-lg hover:shadow-purple-500/20">Send</button>
  </div>

  <!-- Typing Indicator -->
  <div id="typing" class="text-xs opacity-70 h-4 text-center text-gray-300"></div>

<script>
  const socket = io();
  const roomId = location.pathname.split('/').pop();

  // Persistent peer ID (8 chars)
  let peerId = localStorage.getItem('void_peer');
  if (!peerId) {
    peerId = crypto.randomUUID().slice(0,8);
    localStorage.setItem('void_peer', peerId);
  }

  let key, replyTo = null;

  // === INIT ===
  (async () => {
    document.getElementById('code').textContent = `Room: ${roomId}`;

    const base = await crypto.subtle.importKey('raw', new TextEncoder().encode(roomId), 'PBKDF2', false, ['deriveKey']);
    key = await crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt: new TextEncoder().encode('v'), iterations: 100000, hash: 'SHA-256' },
      base, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']
    );

    socket.emit('join', { room: roomId, peer: peerId });
  })();

  // === SOCKET ===
  socket.on('h', async h => {
    const m = document.getElementById('msgs'); m.innerHTML = '';
    for (const x of h) {
      const t = await decrypt(x.c, x.i);
      const repText = x.rep ? await getReplyText(x.rep) : null;
      add(t, x.s === peerId, x.s, x._id, repText);
    }
  });

  socket.on('m', async x => {
    if (x.s === peerId) return;
    const t = await decrypt(x.c, x.i);
    const repText = x.rep ? await getReplyText(x.rep) : null;
    add(t, false, x.s, x._id, repText);
  });

  socket.on('o', n => { document.getElementById('online').textContent = `${n} online`; });
  socket.on('t', ({ s, t }) => { document.getElementById('typing').textContent = t ? `${s} is typing...` : ''; });
  socket.on('lm', lm => { document.getElementById('lm').textContent = lm; });

  // === REPLY ===
  function reply(msgId, sender, text) {
    replyTo = msgId;
    const preview = `${sender}: ${text.slice(0, 30)}${text.length > 30 ? '...' : ''}`;
    document.getElementById('replyText').textContent = preview;
    document.getElementById('replyPreview').classList.remove('hidden');
    document.getElementById('inp').focus();
  }

  function cancelReply() {
    replyTo = null;
    document.getElementById('replyPreview').classList.add('hidden');
  }

  async function getReplyText(repId) {
    return '[reply]';
  }

  // === SEND ===
  async function send() {
    const inp = document.getElementById('inp');
    const text = inp.value.trim();
    if (!text) return;

    add(text, true, peerId, null, replyTo ? await getReplyText(replyTo) : null);

    const data = await encrypt(text);
    socket.emit('m', { ...data, rep: replyTo });

    inp.value = '';
    cancelReply();
  }

  // === ADD MESSAGE ===
  function add(text, isMe, sender, msgId, replyText) {
    const div = document.createElement('div');
    div.className = `flex ${isMe ? 'justify-end' : 'justify-start'} msg group items-end`;
    if (msgId) div.dataset.id = msgId;

    // Reply Button (Discord-style)
    if (!isMe && msgId) {
      const btn = document.createElement('button');
      btn.innerHTML = '↩'; // Simple arrow icon
      btn.className = 'reply-btn';
      btn.onclick = (e) => {
        e.stopPropagation();
        reply(msgId, sender, text);
      };
      div.appendChild(btn);
    }

    const bubble = document.createElement('div');
    bubble.className = `max-w-[70%] px-4 py-2.5 rounded-2xl text-sm message-bubble ${
      isMe 
        ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white' 
        : 'bg-black/40 text-gray-100'
    }`;

    if (replyText) {
      const rep = document.createElement('div');
      rep.className = 'reply';
      rep.textContent = replyText;
      bubble.appendChild(rep);
    }

    const msg = document.createElement('div');
    msg.textContent = text;
    bubble.appendChild(msg);

    if (!isMe) {
      const name = document.createElement('div');
      name.className = 'sender';
      name.textContent = sender;
      div.appendChild(name);
    }

    div.appendChild(bubble);
    document.getElementById('msgs').appendChild(div);
    div.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  // === CRYPTO ===
  async function encrypt(text) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const data = new TextEncoder().encode(text);
    const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
    return { c: btoa(String.fromCharCode(...new Uint8Array(ct))), i: btoa(String.fromCharCode(...iv)) };
  }

  async function decrypt(c, i) {
    const ct = Uint8Array.from(atob(c), c => c.charCodeAt(0));
    const iv = Uint8Array.from(atob(i), c => c.charCodeAt(0));
    const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
    return new TextDecoder().decode(pt);
  }

  // === INPUT ===
  document.getElementById('inp').addEventListener('keypress', e => {
    if (e.key === 'Enter') send();
    clearTimeout(window.t);
    socket.emit('t', true);
    window.t = setTimeout(() => socket.emit('t', false), 1000);
  });
</script>
</body>
</html>
