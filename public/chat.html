<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VoidChat Room</title>
  <link rel="manifest" href="/manifest.json"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    .g{backdrop-filter:blur(12px)}
    .reply { border-left: 3px solid #9333ea; padding-left: 8px; font-size: 0.75rem; opacity: 0.8; }
  </style>
</head>
<body class="h-full bg-gradient-to-br from-gray-900 to-purple-900 text-white flex flex-col max-w-4xl mx-auto p-4 gap-3">

  <!-- Header -->
  <div class="flex justify-between items-center text-xs">
    <span id="code" class="font-mono bg-white/10 px-2 py-1 rounded"></span>
    <span id="online">0 online</span>
  </div>

  <!-- Last Message -->
  <div id="lm" class="text-xs opacity-60 h-5 text-center"></div>

  <!-- Messages -->
  <div id="msgs" class="flex-1 overflow-y-auto g rounded-xl p-3 space-y-2 text-sm"></div>

  <!-- Reply Preview -->
  <div id="replyPreview" class="hidden bg-white/5 p-2 rounded text-xs">
    <div class="flex justify-between">
      <span id="replyText"></span>
      <button onclick="cancelReply()" class="text-red-400">×</button>
    </div>
  </div>

  <!-- Input -->
  <div class="flex gap-1">
    <input id="inp" placeholder="Type message..." class="flex-1 p-2 rounded bg-white/10 border border-white/20 focus:outline-none text-sm"/>
    <button onclick="send()" class="bg-gradient-to-r from-purple-600 to-pink-600 px-4 rounded text-sm font-bold">Send</button>
  </div>

  <!-- Typing -->
  <div id="typing" class="text-xs opacity-60 h-4"></div>

<script>
  const socket = io();
  const roomId = location.pathname.split('/').pop();
  const peer = crypto.randomUUID().slice(0,8);
  let key, replyTo = null;

  // === INIT ===
  (async () => {
    document.getElementById('code').textContent = roomId;

    const base = await crypto.subtle.importKey('raw', new TextEncoder().encode(roomId), 'PBKDF2', false, ['deriveKey']);
    key = await crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt: new TextEncoder().encode('v'), iterations: 100000, hash: 'SHA-256' },
      base, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']
    );

    socket.emit('join', { room: roomId, peer });
  })();

  // === SOCKET ===
  socket.on('h', async h => {
    const m = document.getElementById('msgs'); m.innerHTML = '';
    for (const x of h) {
      const t = await decrypt(x.c, x.i);
      add(t, x.isMe, x.s, x._id, x.rep ? await getReplyText(x.rep) : null);
    }
  });

  socket.on('m', async x => {
    if (x.s === peer) return;
    const t = await decrypt(x.c, x.i);
    const repText = x.rep ? await getReplyText(x.rep) : null;
    add(t, false, x.s, x._id, repText);
  });

  socket.on('o', n => { document.getElementById('online').textContent = n + ' online'; });
  socket.on('t', ({ s, t }) => { document.getElementById('typing').textContent = t ? s + ' typing...' : ''; });
  socket.on('lm', lm => { document.getElementById('lm').textContent = lm; });

  // === REPLY ===
  function reply(msgId, sender, text) {
    replyTo = msgId;
    const preview = `${sender}: ${text.slice(0, 30)}${text.length > 30 ? '...' : ''}`;
    document.getElementById('replyText').textContent = preview;
    document.getElementById('replyPreview').classList.remove('hidden');
    document.getElementById('inp').focus();
  }

  function cancelReply() {
    replyTo = null;
    document.getElementById('replyPreview').classList.add('hidden');
  }

  async function getReplyText(repId) {
    const msg = (await Msg.findById(repId).lean());
    if (!msg) return '[deleted]';
    const buffer = Buffer.isBuffer(msg.c) ? msg.c : Buffer.from(msg.c.buffer);
    return (await gunzip(buffer)).toString().slice(0, 30) + '...';
  }

  // === SEND ===
  async function send() {
    const inp = document.getElementById('inp');
    const text = inp.value.trim();
    if (!text) return;

    add(text, true, peer, null, replyTo ? await getReplyText(replyTo) : null);
    const data = await encrypt(text);
    socket.emit('m', { ...data, rep: replyTo });

    inp.value = '';
    cancelReply();
  }

  // === ADD MESSAGE ===
  function add(text, me, sender, msgId, replyText) {
    const div = document.createElement('div');
    div.className = `flex ${me ? 'justify-end' : 'justify-start'} group`;
    if (msgId) div.dataset.id = msgId;

    const bubble = document.createElement('div');
    bubble.className = `max-w-xs px-3 py-2 rounded-xl text-sm relative ${me ? 'bg-gradient-to-r from-purple-600 to-pink-600' : 'bg-white/10'}`;

    // Reply quote
    if (replyText) {
      const rep = document.createElement('div');
      rep.className = 'reply mb-1';
      rep.textContent = replyText;
      bubble.appendChild(rep);
    }

    // Message text
    const msg = document.createElement('div');
    msg.textContent = text;
    bubble.appendChild(msg);

    // Reply button (others only)
    if (!me && msgId) {
      const btn = document.createElement('button');
      btn.textContent = '↩';
      btn.className = 'absolute -left-6 top-1 opacity-0 group-hover:opacity-100 text-xs';
      btn.onclick = () => reply(msgId, sender, text);
      div.appendChild(btn);
    }

    // Sender name
    if (!me) {
      const name = document.createElement('div');
      name.className = 'text-xs opacity-70 mt-1';
      name.textContent = sender;
      div.appendChild(name);
    }

    div.appendChild(bubble);
    document.getElementById('msgs').appendChild(div);
    div.scrollIntoView({ behavior: 'smooth' });
  }

  // === CRYPTO ===
  async function encrypt(text) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const data = new TextEncoder().encode(text);
    const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
    return { c: btoa(String.fromCharCode(...new Uint8Array(ct))), i: btoa(String.fromCharCode(...iv)) };
  }

  async function decrypt(c, i) {
    const ct = Uint8Array.from(atob(c), c => c.charCodeAt(0));
    const iv = Uint8Array.from(atob(i), c => c.charCodeAt(0));
    const pt = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
    return new TextDecoder().decode(pt);
  }

  // === INPUT ===
  document.getElementById('inp').addEventListener('keypress', e => {
    if (e.key === 'Enter') send();
    clearTimeout(window.t);
    socket.emit('t', true);
    window.t = setTimeout(() => socket.emit('t', false), 1000);
  });
</script>
</body>
</html>
